# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Records a dataset. Actions for the robot can be either generated by teleoperation or by a policy.

Example:

```shell
lerobot-record \
    --robot.type=so100_follower \
    --robot.port=/dev/tty.usbmodem58760431541 \
    --robot.cameras="{laptop: {type: opencv, camera_index: 0, width: 640, height: 480}}" \
    --robot.id=black \
    --dataset.repo_id=aliberts/record-test \
    --dataset.num_episodes=2 \
    --dataset.single_task="Grab the cube" \
    # <- Teleop optional if you want to teleoperate to record or in between episodes with a policy \
    # --teleop.type=so100_leader \
    # --teleop.port=/dev/tty.usbmodem58760431551 \
    # --teleop.id=blue \
    # <- Policy optional if you want to record with a policy \
    # --policy.path=${HF_USER}/my_policy \
```

Example recording with bimanual so100:
```shell
lerobot-record \
  --robot.type=bi_so100_follower \
  --robot.left_arm_port=/dev/tty.usbmodem5A460851411 \
  --robot.right_arm_port=/dev/tty.usbmodem5A460812391 \
  --robot.id=bimanual_follower \
  --robot.cameras='{
    left: {"type": "opencv", "index_or_path": 0, "width": 640, "height": 480, "fps": 30},
    top: {"type": "opencv", "index_or_path": 1, "width": 640, "height": 480, "fps": 30},
    right: {"type": "opencv", "index_or_path": 2, "width": 640, "height": 480, "fps": 30}
  }' \
  --teleop.type=bi_so100_leader \
  --teleop.left_arm_port=/dev/tty.usbmodem5A460828611 \
  --teleop.right_arm_port=/dev/tty.usbmodem5A460826981 \
  --teleop.id=bimanual_leader \
  --display_data=true \
  --dataset.repo_id=${HF_USER}/bimanual-so100-handover-cube \
  --dataset.num_episodes=25 \
  --dataset.single_task="Grab and handover the red cube to the other arm"
```
"""

import logging
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from pprint import pformat

from lerobot.cameras import (  # noqa: F401
    CameraConfig,  # noqa: F401
)
from lerobot.cameras.opencv.configuration_opencv import OpenCVCameraConfig  # noqa: F401
from lerobot.cameras.realsense.configuration_realsense import RealSenseCameraConfig  # noqa: F401
from lerobot.configs import parser
from lerobot.configs.policies import PreTrainedConfig
from lerobot.datasets.image_writer import safe_stop_image_writer
from lerobot.datasets.lerobot_dataset import LeRobotDataset
from lerobot.datasets.utils import build_dataset_frame, hw_to_dataset_features
from lerobot.datasets.video_utils import VideoEncodingManager
from lerobot.policies.factory import make_policy
from lerobot.policies.pretrained import PreTrainedPolicy
from lerobot.robots import (  # noqa: F401
    Robot,
    RobotConfig,
    bi_so100_follower,
    hope_jr,
    koch_follower,
    make_robot_from_config,
    so100_follower,
    so101_follower,
    cr5af_follower
)
from lerobot.teleoperators import (  # noqa: F401
    Teleoperator,
    TeleoperatorConfig,
    bi_so100_leader,
    homunculus,
    koch_leader,
    make_teleoperator_from_config,
    so100_leader,
    so101_leader,
    keyboard,
    gello_leader
)
from lerobot.teleoperators.keyboard.teleop_keyboard import KeyboardTeleop
from lerobot.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
)
from lerobot.utils.robot_utils import busy_wait
from lerobot.utils.utils import (
    get_safe_torch_device,
    init_logging,
    log_say,
)
from lerobot.utils.visualization_utils import _init_rerun, log_rerun_data


@dataclass
class DatasetRecordConfig:
    # Dataset identifier. By convention it should match '{hf_username}/{dataset_name}' (e.g. `lerobot/test`).
    repo_id: str
    # A short but accurate description of the task performed during the recording (e.g. "Pick the Lego block and drop it in the box on the right.")
    single_task: str
    # Root directory where the dataset will be stored (e.g. 'dataset/path').
    root: str | Path | None = None
    # Limit the frames per second.
    fps: int = 30
    # Number of seconds for data recording for each episode.
    episode_time_s: int | float = 60
    # Number of seconds for resetting the environment after each episode.
    reset_time_s: int | float = 60
    # Number of episodes to record.
    num_episodes: int = 50
    # Encode frames in the dataset into video
    video: bool = True
    # Upload dataset to Hugging Face hub.
    push_to_hub: bool = True
    # Upload on private repository on the Hugging Face hub.
    private: bool = False
    # Add tags to your dataset on the hub.
    tags: list[str] | None = None
    # Number of subprocesses handling the saving of frames as PNG. Set to 0 to use threads only;
    # set to ≥1 to use subprocesses, each using threads to write images. The best number of processes
    # and threads depends on your system. We recommend 4 threads per camera with 0 processes.
    # If fps is unstable, adjust the thread count. If still unstable, try using 1 or more subprocesses.
    num_image_writer_processes: int = 0
    # Number of threads writing the frames as png images on disk, per camera.
    # Too many threads might cause unstable teleoperation fps due to main thread being blocked.
    # Not enough threads might cause low camera fps.
    num_image_writer_threads_per_camera: int = 4
    # Number of episodes to record before batch encoding videos
    # Set to 1 for immediate encoding (default behavior), or higher for batched encoding
    video_encoding_batch_size: int = 1

    def __post_init__(self):
        if self.single_task is None:
            raise ValueError("You need to provide a task as argument in `single_task`.")


@dataclass
class RecordConfig:
    robot: RobotConfig
    dataset: DatasetRecordConfig
    # Whether to control the robot with a teleoperator
    teleop: TeleoperatorConfig | None = None
    # Whether to control the robot with a policy
    policy: PreTrainedConfig | None = None
    # Display all cameras on screen
    display_data: bool = False
    # Use vocal synthesis to read events.
    play_sounds: bool = True
    # Resume recording on an existing dataset.
    resume: bool = False

    def __post_init__(self):
        # HACK: We parse again the cli args here to get the pretrained path if there was one.
        policy_path = parser.get_path_arg("policy")
        if policy_path:
            cli_overrides = parser.get_cli_overrides("policy")
            self.policy = PreTrainedConfig.from_pretrained(policy_path, cli_overrides=cli_overrides)
            self.policy.pretrained_path = policy_path

        if self.teleop is None and self.policy is None:
            raise ValueError("Choose a policy, a teleoperator or both to control the robot")

    @classmethod
    def __get_path_fields__(cls) -> list[str]:
        """This enables the parser to load config from the policy using `--policy.path=local/dir`"""
        return ["policy"]


@safe_stop_image_writer
def record_loop(
    robot: Robot,
    events: dict,
    fps: int,
    dataset: LeRobotDataset | None = None,
    teleop: Teleoperator | list[Teleoperator] | None = None,
    policy: PreTrainedPolicy | None = None,
    control_time_s: int | None = None,
    single_task: str | None = None,
    display_data: bool = False,
):
    if dataset is not None and dataset.fps != fps:
        raise ValueError(f"The dataset fps should be equal to requested fps ({dataset.fps} != {fps}).")

    teleop_arm = teleop_keyboard = None
    if isinstance(teleop, list):
        teleop_keyboard = next((t for t in teleop if isinstance(t, KeyboardTeleop)), None)
        teleop_arm = next(
            (
                t
                for t in teleop
                if isinstance(t, (so100_leader.SO100Leader, so101_leader.SO101Leader, koch_leader.KochLeader))
            ),
            None,
        )

        if not (teleop_arm and teleop_keyboard and len(teleop) == 2 and robot.name == "lekiwi_client"):
            raise ValueError(
                "For multi-teleop, the list must contain exactly one KeyboardTeleop and one arm teleoperator. Currently only supported for LeKiwi robot."
            )

    # if policy is given it needs cleaning up
    if policy is not None:
        policy.reset()

    timestamp = 0
    start_episode_t = time.perf_counter()
    while timestamp < control_time_s:
        start_loop_t = time.perf_counter()

        if events["exit_early"]:
            events["exit_early"] = False
            break
        # 打包OBS
        observation = robot.get_observation() # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # 推理时可能有坑
        # features = dataset.features if dataset is not None else policy.features  # 或其它来源
        # observation_frame = build_dataset_frame(features, observation, prefix="observation")
        
        if policy is not None or dataset is not None:
            observation_frame = build_dataset_frame(dataset.features, observation, prefix="observation")
        # 获取action
        # from policy
        if policy is not None:
            action_values = predict_action(
                observation_frame,
                policy,
                get_safe_torch_device(policy.config.device),
                policy.config.use_amp,
                task=single_task,
                robot_type=robot.robot_type,
            )
            action = {key: action_values[i].item() for i, key in enumerate(robot.action_features)}
        # from teleop!!!!!!!!!!!
        elif policy is None and isinstance(teleop, Teleoperator):
            action = teleop.get_action()
            
            print("Action from teleop:", action)
            from lerobot.utils.utils import enter_pressed, move_cursor_up
            move_cursor_up(2)

        # from teleop and keboard for lekiwi
        elif policy is None and isinstance(teleop, list): 
            # TODO(pepijn, steven): clean the record loop for use of multiple robots (possibly with pipeline)
            arm_action = teleop_arm.get_action()
            arm_action = {f"arm_{k}": v for k, v in arm_action.items()}

            keyboard_action = teleop_keyboard.get_action()
            base_action = robot._from_keyboard_to_base_action(keyboard_action)

            action = {**arm_action, **base_action} if len(base_action) > 0 else arm_action
        else:
            # reset environment without teleop or policy
            # if no policy or teleop is provided, we cannot generate an action
            observation_frame = build_dataset_frame(dataset.features, observation, prefix="observation")

            action_values = predict_action(
                observation_frame,
                policy,
                get_safe_torch_device(policy.config.device),
                policy.config.use_amp,
                task=single_task,
                robot_type=robot.robot_type,
            )
            action = {key: action_values[i].item() for i, key in enumerate(robot.action_features)}
            # raise ValueError("No policy or teleoperator provided, cannot generate action.")
        # else:
        #     logging.info(
        #         "No policy or teleoperator provided, skipping action generation."
        #         "This is likely to happen when resetting the environment without a teleop device."
        #         "The robot won't be at its rest position at the start of the next episode."
        #     )
        #     continue

        # 打包action
        # Action can eventually be clipped using `max_relative_target`,
        # so action actually sent is saved in the dataset.
        sent_action = robot.send_action(action) # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if dataset is not None:
            action_frame = build_dataset_frame(dataset.features, sent_action, prefix="action")
            frame = {**observation_frame, **action_frame}
            dataset.add_frame(frame, task=single_task)

        if display_data:
            log_rerun_data(observation, action)

        dt_s = time.perf_counter() - start_loop_t
        busy_wait(1 / fps - dt_s)

        timestamp = time.perf_counter() - start_episode_t


@parser.wrap()
def record(cfg: RecordConfig) -> LeRobotDataset:
    init_logging()
    logging.info(pformat(asdict(cfg)))
    if cfg.display_data:
        _init_rerun(session_name="recording")

    robot = make_robot_from_config(cfg.robot)
    # robot = cr5af_follower.CR5AFFollower(cfg.robot)  # FOR CR5AF
    teleop = make_teleoperator_from_config(cfg.teleop) if cfg.teleop is not None else None

    action_features = hw_to_dataset_features(robot.action_features, "action", cfg.dataset.video)
    obs_features = hw_to_dataset_features(robot.observation_features, "observation", cfg.dataset.video)
    dataset_features = {**action_features, **obs_features}

    if cfg.resume:
        dataset = LeRobotDataset(
            cfg.dataset.repo_id,
            root=cfg.dataset.root,
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )

        if hasattr(robot, "cameras") and len(robot.cameras) > 0:
            dataset.start_image_writer(
                num_processes=cfg.dataset.num_image_writer_processes,
                num_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            )
        sanity_check_dataset_robot_compatibility(dataset, robot, cfg.dataset.fps, dataset_features)
    else:
        # Create empty dataset or load existing saved episodes
        sanity_check_dataset_name(cfg.dataset.repo_id, cfg.policy)
        dataset = LeRobotDataset.create(
            cfg.dataset.repo_id,
            cfg.dataset.fps,
            root=cfg.dataset.root,
            robot_type=robot.name,
            features=dataset_features,
            use_videos=cfg.dataset.video,
            image_writer_processes=cfg.dataset.num_image_writer_processes,
            image_writer_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )

    # Load pretrained policy
    policy = None if cfg.policy is None else make_policy(cfg.policy, ds_meta=dataset.meta)

    robot.connect()  # ！！！！！！！！！！！！！！！！
    if teleop is not None:
        teleop.connect()

    listener, events = init_keyboard_listener()

    with VideoEncodingManager(dataset):
        recorded_episodes = 0
        while recorded_episodes < cfg.dataset.num_episodes and not events["stop_recording"]:
            log_say(f"Recording episode {dataset.num_episodes}", cfg.play_sounds)
            record_loop(
                robot=robot,
                events=events,
                fps=cfg.dataset.fps,
                teleop=teleop,
                policy=policy,
                dataset=dataset,
                control_time_s=cfg.dataset.episode_time_s,
                single_task=cfg.dataset.single_task,
                display_data=cfg.display_data,
            )

            # Execute a few seconds without recording to give time to manually reset the environment
            # Skip reset for the last episode to be recorded
            if not events["stop_recording"] and (
                (recorded_episodes < cfg.dataset.num_episodes - 1) or events["rerecord_episode"]
            ):
                log_say("Reset the environment", cfg.play_sounds)
                # record_loop(
                #     robot=robot,
                #     events=events,
                #     fps=cfg.dataset.fps,
                #     teleop=teleop,
                #     control_time_s=cfg.dataset.reset_time_s,
                #     single_task=cfg.dataset.single_task,
                #     display_data=cfg.display_data,
                # )
                # 简单地停几秒钟
                import numpy as np
                fps = 30
                duration_s = 10
                dt = 1.0 / fps
                t_end = time.time() + duration_s
                safe = np.zeros(7, dtype=np.float32)
                while time.time() < t_end:
                    # robot.send_action(safe)  # 或者啥都不发，仅观测
                    time.sleep(dt)

            if events["rerecord_episode"]:
                log_say("Re-record episode", cfg.play_sounds)
                events["rerecord_episode"] = False
                events["exit_early"] = False
                dataset.clear_episode_buffer()
                continue

            dataset.save_episode()
            recorded_episodes += 1
            # # 每个episode录制后，归位
            robot.dashboard.ServoJ(0, 0, 90, 0, -90, 0, 1)
            time.sleep(5)



    log_say("Stop recording", cfg.play_sounds, blocking=True)

    robot.disconnect()
    if teleop is not None:
        teleop.disconnect()

    if not is_headless() and listener is not None:
        listener.stop()

    if cfg.dataset.push_to_hub:
        dataset.push_to_hub(tags=cfg.dataset.tags, private=cfg.dataset.private)

    log_say("Exiting", cfg.play_sounds)
    return dataset

# if __name__ == "__main__":
#     record()


# 1) 相机配置（等价于 --robot.cameras '{ front: {...} }'）
front_cam = OpenCVCameraConfig(
    # type="opencv",           # 必填：后端类型
    index_or_path=2,         # 等价于 index_or_path: 0
    width=640,
    height=480,
    fps=30,
)

# 2) 机器人配置（等价于 --robot.type=so101_follower ...）
# 注意：不同机器人/遥操作模块的 Config 类名可能略有不同，
# 一般在对应模块里以 *Config 结尾，比如 SO101FollowerConfig。
robot_cfg = cr5af_follower.CR5AFFOLLOWERConfig(
    port="/dev/ttyACM1",
    id="my_awesome_follower_arm",
    cameras={"front": front_cam},
)

# 3) 遥操作配置（等价于 --teleop.type=so101_leader ...）
teleop_cfg = gello_leader.GELLOLeaderConfig(
    # port="/dev/serial/by-id/usb-FTDI_USB__-__Serial_Converter_FTA0T9HA-if00-port0",
    port="/dev/ttyUSB0",
    id="my_awesome_leader_arm",
    use_degrees=True,
)
# le = gello_leader.GELLOLeaderConfig(port="123", id="my_awesome_leader_arm")
# teleop_cfg = keyboard.KeyboardTeleopConfig(
#     id="my_awesome_leader_arm",
# )

# 4) 数据集/录制配置（对应 --dataset.* 和其他开关）
dataset_cfg = DatasetRecordConfig(
    root="/home/robot/lerobot/outputs/record",  # 可选，等价于 --dataset.root=...
    repo_id="seeedstudio123/test",
    single_task="Grab the black cube",
    num_episodes=1,
    push_to_hub=False,
    episode_time_s=60,
    reset_time_s=10,
    fps=30,
    video=True,
)

# 5) 汇总到 RecordConfig 并开录
cfg = RecordConfig(
    robot=robot_cfg,
    dataset=dataset_cfg,
    teleop=teleop_cfg,
    # display_data=False,   # 等价于 --display_data=true
    display_data=False,   # 等价于 --display_data=true
    play_sounds=True,    # 默认 True
    resume=False,
    # resume=False,
)


if __name__ == "__main__":


    # # If cache for this dataset exists, remove it to start fresh
    # from pathlib import Path
    # import shutil
    # cache_dir = Path("/home/robot/.cache/huggingface/lerobot/seeedstudio123")
    # if cache_dir.exists():
    #     try:
    #         shutil.rmtree(cache_dir)
    #         print(f"Removed existing cache directory: {cache_dir}")
    #     except Exception as e:
    #         print(f"Failed to remove cache directory {cache_dir}: {e}")

    # Ensure serial device permissions so the script can open the teleop port.
    # Prefer using the configured teleop port if available, else fall back to /dev/ttyUSB0.
    import os
    import subprocess
    try:
        device_path = Path(teleop_cfg.port) if "teleop_cfg" in globals() and getattr(teleop_cfg, "port", None) else Path("/dev/ttyUSB0")
        if device_path.exists():
            try:
                if os.geteuid() == 0:
                    os.chmod(device_path, 0o777)
                else:
                    subprocess.run(["sudo", "chmod", "777", str(device_path)], check=True)
                    print(f"Set permissions 777 on {device_path}")
                    subprocess.run(["sudo", "chmod", "777", "/dev/ttyACM0"], check=True)
                print(f"Set permissions 777 on {device_path}")
            except Exception as e:
                print(f"Failed to set permissions on {device_path}: {e}")
        else:
            print(f"Device {device_path} does not exist; skipping chmod.")
    except Exception as e:
        print(f"Unexpected error while setting device permissions: {e}")

    # record(cfg)  # This starts the recording process

    # After recording, convert the saved parquet file to CSV for easier inspection
    # import pandas as pd
    # import os
    # loaded_df = pd.read_parquet('/home/robot/.cache/huggingface/lerobot/seeedstudio123/test/data/chunk-000/episode_000000.parquet')
    # loaded_df.to_csv("full_data.csv", index=False)
    # first_10_rows = loaded_df.head(10)
    # first_10_rows.to_csv("first_10_rows.csv", index=False)

    import sys
    from lerobot.utils.utils import init_logging

    # 录制
    sys.argv = [
    "record.py",

    # Robot（CR5 跟随臂 + 相机在 robot 命名空间）
    "--robot.type=cr5af_follower",
    "--robot.port=/dev/ttyACM1",
    "--robot.id=my_awesome_follower_arm",
    '--robot.cameras={"front": {"type": "opencv", "index_or_path": 2, "width": 640, "height": 480, "fps": 30}}',

    # Teleop（主控臂）
    "--teleop.type=gello_leader",
    "--teleop.port=/dev/ttyUSB0",
    "--teleop.id=my_awesome_leader_arm",
    "--teleop.use_degrees=true",

    # Dataset（只本地）
    "--dataset.repo_id=seeedstudio123/test",
    "--dataset.root=/home/robot/lerobot/outputs/11-14/record",
    "--dataset.single_task=Grab the black cube",
    "--dataset.num_episodes=20",
    "--dataset.episode_time_s=60",
    "--dataset.reset_time_s=10",        # ← 拼写必须是 reset_time_s
    "--dataset.fps=30",
    "--dataset.video=true",
    "--dataset.push_to_hub=false",      # 不推 Hub，且不要提供 repo_id

    # 其他
    "--display_data=false",
    "--play_sounds=true",
    "--resume=true",
]
    # 推理
    # act
#     sys.argv = [
#     "record.py",
#     "--robot.type=cr5af_follower",
#     "--robot.port=/dev/ttyACM1",
#     "--robot.cameras={front: {type: opencv, index_or_path: 2, width: 640, height: 480, fps: 30}}",
#     "--robot.id=my_awesome_follower_arm",
#     "--display_data=false",
#     "--dataset.repo_id=seeed/eval_test123",
#     "--dataset.root=/home/robot/lerobot/outputs/eval1111",                                            # data root
#     "--dataset.single_task=Put lego brick into the transparent box",
#     "--policy.path=outputs/act1111/checkpoints/last/pretrained_model",
# ]
    # diffusion
#     sys.argv = [
#     "record.py",
#     "--robot.type=cr5af_follower",
#     "--robot.port=/dev/ttyACM1",
#     "--robot.cameras={front: {type: opencv, index_or_path: 2, width: 640, height: 480, fps: 30}}",
#     "--robot.id=my_awesome_follower_arm",
#     "--display_data=false",
#     "--dataset.repo_id=seeed/eval_test123",
#     "--dataset.root=/home/robot/lerobot/outputs/eval1111",                                            # data root
#     "--dataset.single_task=Put lego brick into the transparent box",
#     "--policy.path=outputs/11-14/diffusion/checkpoints/last/pretrained_model",
# ]
    # smolvla
#     sys.argv = [
#     "record.py",
#     "--robot.type=cr5af_follower",
#     "--robot.port=/dev/ttyACM1",
#     "--robot.cameras={front: {type: opencv, index_or_path: 2, width: 640, height: 480, fps: 30}}",
#     "--robot.id=my_awesome_follower_arm",
#     "--display_data=false",
#     "--dataset.repo_id=seeed/eval_test123",                                                         # data repo
#     # "--dataset.root=/home/robot/lerobot/outputs/record",                                            # data root
#     "--dataset.single_task=Put lego brick into the transparent box",
#     "--policy.path=outputs/smolvlatest/checkpoints/last/pretrained_model",                              # pretrain model
# ]
    init_logging("/home/robot/lerobot/outputs/11-14/record-log.txt")
    record()
